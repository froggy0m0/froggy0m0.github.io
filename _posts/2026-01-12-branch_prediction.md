---
title: 부등호가 쏘아 올린 성능 최적화 (2) - 분기 예측
date: 2026-01-12 00:00:00 +0900
description: CPU가 일을 못하는건 니가 짠 코드 때문이야
categories: [CS, OS]
tags: [cs, os]     # TAG names should always be lowercase
pin: false
math: true
mermaid: true
image:
  path: /assets/img/20260112/branch_prediction/thumbnail.png
  alt: 
  show_in_content: true
---



[지난 포스팅](../instruction_pipeline)에서는 명령어를 병렬로 처리하여 CPU 성능을 높이는 **명령어 파이프라인**을 살펴보았습니다.

하지만 분기문을 만나면 **결과가 확정되기 전엔 다음 명령어를 가져올 수 없어** 파이프라인이 멈추는 제어 해저드(Control Hazard)가 발생합니다."

이러한 비효율을 막기 위해, 결과를 기다리지 않고 미리 실행하는 기술이 바로 **분기 예측(Branch Prediction)**입니다.



## Branch Prediction (분기 예측)

인텔의 최적화 공식 문서에서는 분기예측을 다음과 같이 기술하고 있습니다.

> *"It enables the processor to begin executing instructions long before the branch outcome is certain."*
>
> 분기 결과가 확정되기 훨씬 전부터, 프로세서가 명령어 실행을 시작할 수 있게 해준다.
> <br>
> <small>— Intel  64 and IA-32 Architectures Optimization Reference Manual 中<small>

​    

즉, 분기 예측이란 **결과를 미리 예측해 실행함으로써** 파이프라인의 흐름을 유지하는 CPU의 최적화 기술입니다.

​    

이해를 돕기 위해 간단한 예시를 들어보겠습니다.

```java
if (a > 10) {
   a = a + 1;
}
a = a + 2;
```

위 예시에서 조건문 내부에 있는 `a = a + 1`을 실행할지 여부는,  `if`문의 결과가 확정될 때까지 기다려야 합니다. 

<br>

| 구분 | T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 |
| :--: | ----- | :---: | :---: | ----- | :---: | :---: | :---: | :---: |
| **a>10** | **F** | **D** | **E** | **W** | | | | |
| **a=a+1** | |   ☁️   | **☁️** | **F** | **D** | **E** | **W** |  |
| **a=a+2** | |       |  |  | **F** | **D** | **E** | **W** |


`if`문의 판별 결과가 나오기 전까지, 프로세서는 **다음에 실행할 명령어**를 가져오지(Fetch) 못합니다.

이로 인해 파이프라인이 잠시 멈추는 **지연(Stall, ☁️)** 이 발생하며, 후속 처리를 담당할 유닛들은 빈 상태(IDLE)로 남게 되어 클럭 사이클을 흘려보내게 됩니다.

<br>🤔 **그렇다면, 결과를 기다리지 않고 미리 예측하여 움직인다면 어떻게 될까요?**

<br>

------

### A. 예측 성공
CPU가 `if`문의 결과를 미리 **True로 가정(예측)**하고,  지연 없이 다음 명령어를 실행하는 경우입니다.


| **구분**                 | **T1** | **T2** | **T3** | **T4** | **T5** | **T6** |
| ------------------------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **분기 (`if (a > 10)`)** | **F**  | **D**  | **E**  | **W**  |        |        |
| **예측 (`a = a + 1`)**   |        | **F**  | **D**  | **E**  | **W**  |        |
| **다음 (`a = a + 2`)**   |        |        | **F**  | **D**  | **E**  | **W**  |

위 표를 보면 `if(a > 10)`문의 연산이 진행되는 동안(T2, T3), 파이프라인이 멈추지 않고 바로 다음 명령어(`a = a + 1`)를 가져와(Fetch)하여 채워 넣습니다.

결과적으로 파이프라인이 **멈춤 없이** **연속적**으로 처리되어, **2사이클(Cycle)이 단축**되었습니다.

<br>
**🤔 하지만, 만약 예측이 빗나간다면 어떻게 될까요?**

<br>

------

### B. 예측 실패
예측이 빗나간 경우입니다.

예측과 달리 조건이 (`a <= 10`)인 경우입니다. 이때 CPU는 실행 단계(**E**)에서 예측이 틀렸음을 감지하고, 이미 파이프라인에 들어와 있던 잘못된 명령어들을 모두 비워내는 **Pipeline Flush**를 수행합니다.

이후  올바른 분기 지점의 첫 번째 명령어를 가져오는 Fetch단계부터 파이프라인을 다시 새롭게 채우기 시작합니다.

| **구분**                 | **T1** | **T2** | **T3** | **T4**    | **T5** | **T6** |
| ------------------------ | ------ | ------ | ------ | --------- | ------ | ------ |
| **분기 (`if (a > 10)`)** | **F**  | **D**  | **E**  | **W**     |        |        |
| **오답 (`a = a + 1`)**   |        | **F**  | **D**  | **Flush** | -      | -      |
| **정답 (`a = a + 2`)**   |        |        |        | **F**     | **D**  | **E**  |



**Pipeline Flush**는 단순히 **실행 흐름을 바로잡는 것** 이상의 비용이 듭니다.

이미 파이프라인의 잘못된 명령어들을 전부 비워내고, 내부 상태를 초기화하는 추가 **비용**까지 필요하기 때문입니다.

<br>

**그렇다면 프로세스는 도대체 어떻게 분기를 예측하는 걸까요?**

<br>

------

### 💡 CPU는 무엇을 근거로 예측할까?

예측 방식은 크게 두 가지로 나뉩니다.

#### 1. 정적 분기 예측 (Static Prediction)

실행 이력(History)없이, **코드의 구조적 특징**만을 분석하여 정해진 규칙대로 예측하는 방식입니다.

##### **BTFNT (Backwards Taken, Forwards Not Taken)**

  - **Backwards (Taken):** 분기 목적지가 현재 시점보다 **이전 주소(과거)**라면, `for`나 `while` 같은 **반복문)**의 재실행으로 간주하여 **실행(Taken)**으로 예측합니다.
  - **Forwards (Not Taken):** 분기 목적지가 현재 시점보다 **이후 주소(미래)**라면, `if` 문의 조건 불만족 시 블록을 건너뛰는 상황으로 간주하여 **실행 안 함(Not Taken)**으로 예측합니다.

##### **Unconditional branches** 

- 조건 없이 이동(*return*, *break*)하는 경우, 항상 **실행될(Taken) 것으로 예측합니다.**

##### **Indirect branches**

- 다음 분기를 위해 **메모리 값을 참조**해야 하는 경우, **실행되지 않을(Not Taken) 것으로 예측합니다.**

<br>

#### 2. 동적 분기 예측 (Dynamic Prediction)

프로세서는 이전에 수행했던 분기 명령의 **기록을 저장**해두고, 이를 다시 참조하여 다음 실행 경로를 예측합니다.

##### BTB / BHT (Branch Target Buffer / History Table)

- 프로세서는 **Branch History Table**과 **Branch Target Buffer**를 사용하여 분기의 방향과 목적지를 예측합니다.
  - **Branch Target Buffer (BTB):** 분기할 **목적지 주소**를 저장합니다.
  - **Branch History Table (BHT):** 분기의 **실행 결과(Taken/Not Taken)**를 저장합니다.

<br>

------

#### 🔄 예측의 흐름: 정적에서 동적으로

그렇다면 CPU는 어떤 상황에서 정적 혹은 동적 방식을 선택할까요? 인텔 공식 문서(Optimization Reference Manual)에서는 그 전환 기준을 **BTB(Branch Target Buffer) 기록 여부**로 설명하고 있습니다.

> *"Branches that do not have a history in the BTB are predicted using a static prediction algorithm."*
>
> BTB에 이력이 없는 분기는 정적 예측 알고리즘을 사용하여 예측된다.
> <br>
> <small>— Intel  64 and IA-32 Architectures Optimization Reference Manual 中<small>

<br>

결국 CPU는 **실행 이력 유무**에 따라 예측 전략을 결정합니다. 

기록이 없는 초기에는 **정적 예측**을, 데이터가 쌓인 후에는 이를 기반으로 한 **동적 예측**을 수행하여 성능을 끌어올립니다.

예측 방식은 다양하지만, 결국 분기 예측의 핵심은 데이터와 흐름 속에서 **'반복되는 패턴'**을 찾아내는 것입니다.

<br>

------

<br>

"지금까지 CPU가 성능을 최적화 하기위해 사용하는 **분기 예측** 기술에 대해 알아보았습니다.

CPU는 정적 규칙과 동적 이력(BTB)을 통해 끊임없이 다음 경로를 미리 파악하려 합니다. 하지만 이러한 예측 메커니즘도 결국 **과거의 실행 흐름과 데이터의 일관성**에 의존할 수밖에 없습니다. 결국 분기 예측은 불필요한 연산의 리스크를 감수해야 합니다.

그렇다면 **애플리케이션의 성능을 최대한 끌어올리기 위해** 우리는 어떤 코드를 작성해야 할까요?

다음 포스팅에서는 간단한 예제를 바탕으로 **분기 예측 성능 최적화 전략**을 살펴보겠습니다.